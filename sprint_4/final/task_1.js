/*
-- УСЛОВИЕ ЗАДАЧИ --
В этой задаче можно пользоваться хеш-таблицами из стандартных библиотек.

Тимофей пишет свою поисковую систему.

Имеется n документов, каждый из которых представляет собой текст из слов. По этим документам 
требуется построить поисковый индекс. На вход системе будут подаваться запросы. Запрос —– 
некоторый набор слов. По запросу надо вывести 5 самых релевантных документов.

Релевантность документа оценивается следующим образом: для каждого уникального слова из запроса 
берётся число его вхождений в документ, полученные числа для всех слов из запроса суммируются. 
Итоговая сумма и является релевантностью документа. Чем больше сумма, тем больше документ подходит под запрос.

Сортировка документов на выдаче производится по убыванию релевантности. Если релевантности документов совпадают 
—– то по возрастанию их порядковых номеров в базе (то есть во входных данных).

Подумайте над случаями, когда запросы состоят из слов, встречающихся в малом количестве документов. Что если одно 
слово много раз встречается в одном документе?

Формат ввода
В первой строке дано натуральное число n —– количество документов в базе (1 ≤ n ≤ 104).

Далее в n строках даны документы по одному в строке. Каждый документ состоит из нескольких слов, слова отделяются 
друг от друга одним пробелом и состоят из маленьких латинских букв. Длина одного текста не превосходит 1000 символов. 
Текст не бывает пустым.

В следующей строке дано число запросов —– натуральное число m (1 ≤ m ≤ 104). В следующих m строках даны запросы по 
одному в строке. Каждый запрос состоит из одного или нескольких слов. Запрос не бывает пустым. Слова отделяются друг 
от друга одним пробелом и состоят из маленьких латинских букв. Число символов в запросе не превосходит 100.

Формат вывода
Для каждого запроса выведите на одной строке номера пяти самых релевантных документов. Если нашлось менее пяти 
документов, то выведите столько, сколько нашлось. Документы с релевантностью 0 выдавать не нужно.

Пример 1
Ввод	
3
i love coffee
coffee with milk and sugar
free tea for everyone
3
i like black coffee without milk
everyone loves new year
mary likes black coffee without milk

Вывод
1 2
3
2 1
Пример 2
Ввод	
6
buy flat in moscow
rent flat in moscow
sell flat in moscow
want flat in moscow like crazy
clean flat in moscow on weekends
renovate flat in moscow
1
flat in moscow for crazy weekends

Вывод
4 5 1 2 3
Пример 3
Ввод	Вывод
3
i like dfs and bfs
i like dfs dfs
i like bfs with bfs and bfs
1
dfs dfs dfs dfs bfs

Вывод
3 1 2

-- ПРИНЦИП РАБОТЫ --
Для того, чтобы максимально воспользоваться ресурсами машины, которые есть в условии, не жалеем память и создаем "оглавление"(tableOfContents).
Оглавление представляет собой словарь со словами из документов, где они встречаются и сколько раз.
Затем каждый поисковый запрос мы отфильтровываем по уникальным словам, чтобы не проходить по ним несколько раз и поочередно ищем в оглавлении
с подсчетом. 
Таким образом в счетчик попадут только документы с результатом и мы сразу выполним условие выводить только документы с результатом.
В конце сортируем результат и выдаем 5 максимальных.



-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Если учесть худший случай, когда каждый документ имеет уникальные слова, то создание словаря из N элементов + поиск по каждому слову запроса M
    (не будем учитывать спрэд в Set для создания массива уникальных слов запроса), то поиск займет O(M + N).
-- АСИМПТОТИЧЕСКАЯ СЛОЖНОСТЬ --
    Асимптотическая сложность с учетом создания объекта словаря при худшем случае, когда каждое слово есть в каждом документе, то O(M), где М - 
    количество слов
-- Посылка --
    https://contest.yandex.ru/contest/24414/run-report/78902042/
*/


const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
});
let phase = 0;

const tableOfContents = {};
let numberOfDocs = 0;
let numberOfDoc = 1;
let numberOfSearchStrings = 0;

rl.on('line', (input) => {
    if (phase === 0) {
        numberOfDocs = parseInt(input);
    }
    
    if (phase > 0 && phase <= numberOfDocs) {
        input.split(' ').forEach(word => {
            if(tableOfContents[word]) {
                let wordTable = tableOfContents[word];
                if(wordTable[numberOfDoc]) {
                    wordTable[numberOfDoc] = wordTable[numberOfDoc] + 1;
                } else {
                    wordTable[numberOfDoc] = 1;
                }
            } else {
                tableOfContents[word] = {
                    [numberOfDoc]: 1
                }
            }
        })
        numberOfDoc++
    }

    if(phase > numberOfDocs && phase <= numberOfDocs + numberOfSearchStrings) {
        numberOfSearchStrings = parseInt(input);
    }

    if(phase > numberOfDocs + numberOfSearchStrings + 1) {
        const counter = {};

        [...new Set(input.split(' '))].forEach(searshWord => {
            if(tableOfContents[searshWord]) {
                const docs = tableOfContents[searshWord]
                for(let doc in docs) {
                    counter[doc] = counter[doc] ? (counter[doc] + docs[doc]) : docs[doc];
                }
            }
        })

        const result = Object.entries(counter).sort((a, b) => b[1] - a[1]).slice(0, 5).map(item => item[0]).join(' ');
        process.stdout.write(`${result}` + '\n');
    }
    phase++
});