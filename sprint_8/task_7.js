/*

Гоша измерял температуру воздуха n дней подряд. В результате у него получился некоторый временной ряд. 
Теперь он хочет посмотреть, как часто встречается некоторый шаблон в получившейся последовательности. 
Однако температура — вещь относительная, поэтому Гоша решил, что при поиске шаблона длины m (a1, a2, ..., am) 
стоит также рассматривать сдвинутые на константу вхождения. Это значит, что если для некоторого числа c в 
исходной последовательности нашёлся участок вида (a1 + c, a2 + c, ... , am + c), то он тоже считается 
вхождением шаблона (a1, a2, ..., am).

По заданной последовательности измерений X и шаблону A=(a1, a2, ..., am) определите все вхождения A в X, 
допускающие сдвиг на константу.

Подсказка: если вы пишете на питоне и сталкиваетесь с TL, то попробуйте заменить какие-то из циклов 
операциями со срезами.

Формат ввода
В первой строке дано количество сделанных измерений n — натуральное число, не превышающее 104. Во 
второй строке через пробел записаны n целых чисел xi, 0 ≤ xi ≤ 103 –— результаты измерений. В третьей строке дано натуральное число m –— длина искомого шаблона, 1≤ m ≤ n. В четвёртой строке даны m целых чисел ai — элементы шаблона, 0 ≤ ai ≤ 103.

Формат вывода
Выведите через пробел в порядке возрастания все позиции, на которых начинаются вхождения шаблона A 
в последовательность X. Нумерация позиций начинается с единицы.

Пример 1
Ввод	
9
3 9 1 2 5 10 9 1 7
2
4 10
Вывод
1 8

Пример 2
Ввод	
5
1 2 3 4 5
3
10 11 12
Вывод
1 2 3
*/


const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
});

let x;
let y;
let phase = 0;

rl.on("line", (input) => {
  if (phase === 1) {
    const array = input.split(" ")
    x = array.map((item, idx) => {
        if(idx === 0) {
            return 0;
        } else {
            return (item - array[idx - 1]);
        }
    });
  }

  if (phase === 3) {
    const array = input.split(" ")
    y = array.map((item, idx) => {
			if(idx === 0) {
				return 0;
			} else {
				return (item - array[idx - 1]);
			}
		});
  }

//   if (phase === 3) {
//     rl.emit("close");
//   }
  phase++;
});

rl.on("close", () => {
    const starts = [];
    const prefix = y.slice(1).join(' ');

    for(let i = 1; i < x.length; i++) {
        if(x[i] === y[1] && i + y.length - 1 <= x.length) {
            if(x.slice(i, i + y.length - 1).join(' ') === prefix) {
                starts.push(i)
            }
        }
    }

    process.stdout.write(`${starts.join(' ')}` + "\n");
});