/*
-- УСЛОВИЕ ЗАДАЧИ --
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, 
и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной 
отсортированной последовательности. Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность находить в нем элемент за 
O(logn).
Можно предполагать, что в массиве только уникальные элементы.
Задачу необходимо сдавать с компилятором Make, он выбран по умолчанию, других компиляторов в задаче нет. Решение отправляется файлом. 
Требуемые сигнатуры функций лежат в заготовках кода на диске.

От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Файлы с заготовками кода, содержащими сигнатуры функций 
и базовый тест для поддерживаемых языков, находятся на Яндекс.Диске по ссылке. Обратите внимание, что считывать данные и выводить ответ не требуется.
Расширение файла должно соответствовать языку, на котором вы пишете (.cpp, .java, .go, .js, .py). Если вы пишете на Java, назовите файл с 
решением Solution.java, для C# – Solution.cs. Для остальных языков название может быть любым, кроме solution.ext, где ext – разрешение для вашего языка.

Формат ввода
Функция принимает массив натуральных чисел и искомое число k. Длина массива не превосходит 10000. Элементы массива и число k не превосходят по значению 
10000.
В примерах:
В первой строке записано число n –— длина массива.
Во второй строке записано положительное число k –— искомый элемент. 
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Формат вывода
Функция должна вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть −1.
Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от 100000 до 1000000 раз.

Пример 1
Ввод	
9
5
19 21 100 101 1 4 5 7 12
Вывод
6
Пример 2
Ввод	
2
1
5 1
Вывод
1

-- ПРИНЦИП РАБОТЫ --
Сначала нужно исключить граничные условия:
    - массив из двух элементов
    - массив из одного элемента
    - искомый элемент - это начало или конец массива.
Затем запускаем цикл проверки.
На первом уровне условного блока мы проверяем отсортирована ли проверяемая часть массива или нет. Если да, то применяем обычный бинарный поиск, если нет:
    - проверяем какая часть массива отсортирована
    - проверяем может ли искомый элемент находиться в отсортированной части. Если да - бинарный поиск в следующем цикле, если нет, повторяем 
    всё заново с новыми началом, окончанием и серединой.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Так как алгоритм представляет всё тот же бинарный поиск, но с доп условием, то это O(logn)
-- АСИМПТОТИЧЕСКАЯ СЛОЖНОСТЬ --
    Мы работаем с исходным массивом и не создаем новых объектов, поэтому O(n)

-- Посылка --
    https://contest.yandex.ru/contest/23815/run-report/76446319/
*/


function brokenSearch(arr, k) {
    let start = 0;
    let end = arr.length - 1;
    let middle = Math.floor((end + start) / 2);

    /*
    проверим граничные условия:
     - массив из двух элементов
     - массив из одного элемента
     - искомый элемент - это начало или конец массива    
    */

    if(k === arr[0]) return 0;
    if(k === arr[end]) return end;
    if(arr.length === 2)  return -1;

    while((end - start) > 1) {
        if (arr[middle] === k) return middle;

        //если массив отсортирован
        if(arr[start] < arr[end]) {
            if(arr[middle] < k) {
                start = middle;
                middle = Math.floor((end + start) / 2);
            } else {
                end = middle;
                middle = Math.floor((end + start) / 2);
            }
        //если массив неотсортирован
        } else {           
            //случай с НЕотсортированной левой частью и отсортированной правой
            if(arr[middle] < arr[end] && arr[middle] < arr[start]) {
                //элемент находится правее
                if (arr[middle] < k && k < arr[end]) {
                    start = middle;
                    middle = Math.floor((end + start) / 2);
                //элемент находится левее
                } else {
                    end = middle;
                    middle = Math.floor((end + start) / 2);
                }
            //случай с отсортированной левой частью и НЕотсортированной правой
            } else {
                //элемент находится левее
                if (arr[middle] > k &&  k > arr[start]) {
                    end = middle;
                    middle = Math.floor((end + start) / 2);
                //элемент находится правее
                } else {
                    start = middle;
                    middle = Math.floor((end + start) / 2);
                }
            }
        }
    }
    return -1;
}