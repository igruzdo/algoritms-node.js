/*
Напишите функцию, совершающую просеивание вниз в куче на максимум. Гарантируется, что порядок элементов в 
куче может быть нарушен только элементом, от которого запускается просеивание.
Функция принимает в качестве аргументов массив, в котором хранятся элементы кучи, и индекс элемента, от 
которого надо сделать просеивание вниз. Функция должна вернуть индекс, на котором элемент оказался после 
просеивания. Также необходимо изменить порядок элементов в переданном в функцию массиве.
Индексация в массиве, содержащем кучу, начинается с единицы. Таким образом, сыновья вершины на позиции 
v
 это 
2
v
 и 
2
v
+
1
. Обратите внимание, что нулевой элемент в передаваемом массиве фиктивный, вершина кучи соответствует 1-му элементу.
PIC

Формат ввода
Элементы кучи —– целые числа, лежащие в диапазоне от -10^9 до 10^9. 
Все элементы кучи уникальны. Передаваемый в функцию индекс лежит в диапазоне от 1 до размера 
передаваемого массива. В куче содержится от 1 до 10^5 элементов.
Замечания про отправку решений
По умолчанию выбран компилятор make. Решение нужно отправлять в виде файла с 
расширением, которое соответствует вашему языку программирования. Если вы пишете на Java, имя файла должно быть Solution.java, 
для C# – Solution.cs. Для остальных языков назовите файл my_solution.ext, заменив ext на необходимое расширение.

*/

function siftDown(heap, idx) {
    let findIdx;


    function setLargestIdx(heap, idx) {
        let left = 2 * idx;
        let right = 2 * idx + 1;
        let index_largest;

        if(heap.length < left) {
            findIdx = idx;
            return;
        }
    
        if(right <= heap.length && heap[left] < heap[right]) {
            index_largest = right;
        } else {
            index_largest = left
        }
    
        if(heap[idx] < heap[index_largest]) {
            [heap[idx], heap[index_largest]] = [heap[index_largest], heap[idx]];
            findIdx = index_largest;
            setLargestIdx(heap, index_largest);
        } else {
            findIdx = idx; 
        }
    }

    setLargestIdx(heap, idx)

    return findIdx;

}

// function test() {
//     var sample = [-1, 12, 1, 8, 3, 4, 7];
//     console.log(siftDown(sample, 2));
// }
// test();