/*
-- УСЛОВИЕ ЗАДАЧИ --
Расстоянием Левенштейна между двумя строками s и t называется количество атомарных изменений, с 
помощью которых можно одну строку превратить в другую. Под атомарными изменениями подразумеваются: 
удаление одного символа, вставка одного символа, замена одного символа на другой.

Найдите расстояние Левенштейна для предложенной пары строк.

Выведите единственное число — расстояние между строками.

Формат ввода
В первой строке дана строка s, во второй — строка t. Длины обеих строк не превосходят 1000. 
Строки состоят из маленьких латинских букв.

Пример 1
Ввод	Вывод
abacaba
abaabc
Вывод
2

Пример 2
Ввод	
innokentiy
innnokkentia
Вывод
3

Пример 3
Ввод	
r
x
Вывод
1


-- ПРИНЦИП РАБОТЫ --
  Очень печально, что я узнал об алгоритме Вагнера — Фишера для решения этой задачи только после того, как просидел над ней добрых часа 4 и 
  всё-таки решился залезть в гугл. 
  Смысл алгоритма в том что на каждой итерации мы выбираем минимальное значение из трёх вариантов если буквы не совпали:
  - из ячейка выше + 1,
  - из ячейки левее + 1,
  - из ячеки выше и левее + 1;
  если буквы совпали, то сравниваются те же значения, но к ячейке выше и левее не прибавляется единица.
  Так же важно правильно заполнить изначальную матрицу. На нулевом столбце и нулевой строке будут значения от 0 до длины слова.  


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    O(n*m) - на решение задачи + O(n + m) - на построение изначальной матрицы.
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    O(n*m), но можно и уменьшить до O(m*2) за счет очистки матрицы и использования только двух массивов, но так как решение и так с запасом прошло, то 
    тратить на это время не стал. 
-- Посылка --
    https://contest.yandex.ru/contest/25597/run-report/82167117/
*/

const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
});

let x;
let y;
let phase = 0;

rl.on("line", (input) => {
  if (phase === 0) {
    x = input.split("");
  }

  if (phase === 1) {
    y = input.split("");
  }

  if (phase === 1) {
    rl.emit("close");
  }
  phase++;
});

rl.on("close", () => {
  findLCS(x, y);
});

/**
 * функция поиска расстояния ливенштайна
 * @param {Array<string>} X  - первая строка для сравнения
 * @param {Array<string>} Y  - всторая строка для сравнения
 * @returns {void}
 */

function findLCS(X, Y) {
  const m = X.length;
  const n = Y.length;
  const dp = new Array(m + 1);

  for (let i = 0; i <= m; i++) {
    dp[i] = [i];
  }

  for (let j = 0; j <= n; j++) {
    dp[0][j] = [j];
  }

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (X[i - 1] === Y[j - 1]) {
        dp[i][j] = Math.min(
          dp[i][j - 1] + 1,
          dp[i - 1][j] + 1,
          dp[i - 1][j - 1]
        );
      } else {
        dp[i][j] = Math.min(
          dp[i][j - 1] + 1,
          dp[i - 1][j] + 1,
          dp[i - 1][j - 1] + 1
        );
      }
    }
  }

  let lcsLength = dp[m][n];
  process.stdout.write(`${lcsLength}` + "\n");
}
